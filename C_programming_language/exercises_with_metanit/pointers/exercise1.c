/*
Exercise 1:
Write a program in which you define a variable of 
type int and a pointer that points to this variable. 
Print the address of the variable to the console. 
Also output the value of the variable using the 
pointer dereference operation.

Упражнение 1:
Напишите программу, в которой определите переменную 
типа int и указатель, который указывает на эту переменную. 
Выведите на консоль адрес переменной. Также выведите 
значение переменной, используя операцию разыменования 
указателя.
*/

#include <stdio.h>

int main(void)
{
    //опеределение переменной
    int var1;
    
    //определение указателя
    int * pVar1;
    
    //присваиваю переменной значение
    var1 = 15;
    
    //присваение адреса переменной указателю
    pVar1 = &var1;

    //вывод занчени переменной испльзую указатель
    printf("Value * pVar1 = %d \n",  *pVar1);

    //вывод адреса памяти
    //правильно:
    printf("Pointer pVar1 = %p \n", (void*) pVar1);
    //не правильно (не по стандарту):
    printf("Pointer pVar1 = %p \n", (void*) pVar1);

    //(void*) pVar1 - преобразование одного типа данных 
    // в другой (так сказать каст).
    
    /*
    Спецификатор формата %p в printf() предназначен 
    исключительно для вывода адресов (указателей). 
    Согласно стандарту языка C (ISO/IEC 9899):
    Аргумент, соответствующий спецификатору %p, 
    должен быть указателем типа void *. 
    */
    
    /*
    Тип void * — это универсальный указатель, 
    который может хранить адрес любого объекта.
    Все указатели на объекты (например, int *, char *, double *) 
    могут быть неявно преобразованы к void * и обратно без потери информации.
    Однако разные типы указателей могут иметь разное внутреннее представление 
    на некоторых архитектурах (хотя на современных системах, как x86/x64, они одинаковые).
    Чтобы гарантировать переносимость и соответствие стандарту, 
    printf с %p ожидает именно void *. 
    */

    return 0;
}

//gcc exercise1.c -o exercise1 && ./exercise1
